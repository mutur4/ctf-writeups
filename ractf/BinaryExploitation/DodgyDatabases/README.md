> ## Challenge _(The Dodgy Databases challenge}_

1. `fgets()` gets the username input with the max_len 30 bytes.
2. The username `user -> name` is 20 bytes in chars.
3. `strcpy(user -> name, username)` is used to copy the username therefore
this leads to a possible `heap overflow`
4. `free()` the admin pointer is not set to NULL therefore this leads to 
a possible `UAF` vulnerability.

> ## Exploitation _(Find a way to read the flag)_

- This was a *heap_exploitation* challenge.
- The flag is only read when the value of admin() _the value that we freed()_
role is ROLE_GOD or (0xbeefcafe).
- Therefore we have to use the UAF vulnerability to get the value of admin located
back to use and control the value of `admin -> role` to 0xbeefcafe using our 
heap overflow vulnerability and get to read the flag :smile:
- Therefore when we free() the admin object from the heap this will be inserted in 
the `tcache` and since our next allocation is of the same size and allocation from 
the `tcache` is allocated from the head therefore we are allocated the pointer to admin
and using our heap overflow vulnerability we can control the value of `admin -> role` and 
control the value of `ROLE_GOD` and we can therefore read out flag =)

- The final flag for the challenge is: 
	**ractf{w0w_1_w0nD3r_wH4t_free(admin)_d0e5}**
- Check the final exploit @[exploit.py](exploit.py) 
